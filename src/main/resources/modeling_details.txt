Design and Implementation Rules


Section 1: Package Structure and Naming Conventions

Rule 1:
Classes and interfaces should be in separate packages based on the module they belong to. For example, all classes and interfaces related to the organization module should be in the organization package.
The base package should be org.drdeesw.commons.


Section 2: Models and Entity Design

Rule 2:

For the following models, create:
* An interface: Naming convention: {Model}.
* An abstract entity:
  * Use the @MappedSuperclass annotation.
  * Contain all properties, annotated appropriately (@Column, @OneToMany, etc.), and implement the interface.
  * Naming convention: Abstract{Model}Entity.
* A concrete entity:
  * Extend the abstract entity.
  * Use @Entity and @Table annotations.
  * Naming convention: {Model}Entity.
  * Determine the best Hibernate inheritance mapping strategy for the concrete entity based on the model requirements.
  
Rule 3:

In JPA entity classes, all entity relationships (e.g., @OneToMany, @ManyToOne, @OneToOne, @ManyToMany) must reference concrete, mapped entity classes, not interfaces or generic parameters.
* Avoid: Using generics directly in entity relationship fields.
* Abstract Classes: May define generics in method signatures to support flexibility.
* Concrete Classes: Must resolve generics to specific entity types and ensure proper mapping of relationships.
* These rules apply specifically to entity fields using JPA annotations.
Example for OrganizationEntity:

private Set<OrganizationAccountEntity> accounts;  // Correct

private Set<OrganizationAccount> accounts;       // Incorrect
private Set<A> accounts;                         // Incorrect

Rule 4:

Entity relationships in interfaces should reference interfaces or specific types where generics are not used. 
Avoid defining generics in interfaces.


Section 2: Generics and Type Safety

Rule 5:

Remove generics from interfaces to simplify design.
* Relationships in interfaces should use well-defined interface types (e.g., OrganizationAccount).
* Type handling and conversions should occur in abstract or concrete classes, using explicit casts or helper methods where necessary.

Rule 6:

Minimize the use of raw types and unchecked casts to ensure type safety and maintain clean code.


Section 3: Simplifying Redundancies

Rule 7:
The ServiceProvider class does not need getAccounts() and setAccounts() methods, as these are defined in the Organization class.

Rule 8:

The ServiceProviderAccount class does not need getServiceProvider() and setServiceProvider() methods, 
as these are in the OrganizationAccount class as getOrganization() and setOrganization().
These methods should only exist if they delegate directly to the corresponding methods in OrganizationAccount.

Section 4: Best Practices and Interface Design

Rule 9:
Follow industry standards and best practices. If a conflict arises between these standards and the rules outlined here, highlight it for resolution.

Rule 10:

Create interfaces only when there is a clear need for polymorphism, abstraction, or separation of concerns.
* Avoid introducing unnecessary complexity into interfaces, such as generic parameters, unless there is a compelling reason.

Rule 11: Use Lazy @OneToMany Relationships

Default all @OneToMany relationships to lazy-loading.
Use these relationships primarily to define mappings between entities rather than directly traversing them.
When accessing the "many" side, write explicit queries to retrieve the data as needed.
Explicit queries should be written in the service layer to fetch related entities on the 'many' side as needed

Rule 12: Propagate Generics in Abstract Classes

When an interface defines generic parameters, any abstract class implementing the interface must:
* Declare and Propagate:
  Declare and propagate the same generic parameters to maintain consistency with the interface contract.
* Abstract Class Implementation:
  Use the generic parameters in properties and methods where applicable to ensure alignment with the interface.
* Concrete Class Binding:
  Explicitly bind the generic parameters in concrete classes to avoid type mismatches.
Purpose: This ensures type safety, prevents runtime errors, and maintains clarity in the class hierarchy.

Rule 13: Concrete Types for Persistent Relationships

JPA-mapped fields must always use concrete entity types. 
Avoid using generics (T, A, ?) in JPA entity fields, especially in relationships such as @OneToMany, @ManyToOne, @OneToOne, or @ManyToMany.


Model Definitions:

Note: all entity classes are JPA entity classes.

Common Module:

Auditable - a role interface that contains the following properties:
- CreatedBy is the user who created the record
- CreationDate
- LastUpdateDate
- LastUpdatedBy is the user who last updated the record

Describable - a role interface that contains the following properties:
- description, which is a string

Enableable - a role interface that contains the following properties:
- enabled, which is a boolean

Named - a role interface that contains the following properties:
- name, which is a string


Organization Module:

Account, is an auditable, describable, enableable entity
- Issued by an Account Provider, such as a bank or other Organization
- Has an internal ID which is unique across an Account Provider. It could be an account number or a username or email or GUID. It is not guaranteed to be unique across all Account Providers and in fact probably isn't.
- Has an Account Holder

Account Provider, which is named and describable
- Provides Accounts to its Account Holders
- Provided accounts should be managed through `getProvidedAccounts()` and `setProvidedAccounts()`.

Account Holder
- Is a Person, Organization, Service Provider or integrating system (or a subclass of any of those)
- Holds accounts from various account providers.
- Held accounts should be managed through `getHeldAccounts()` and `setHeldAccounts()`.

Organization, which is named and describable
- Can act as both an `AccountProvider` and an `AccountHolder`.
    - **Accounts Provided**: Organization Accounts (or subclasses) issued by the organization as an account provider (e.g., organization memberships, service provider accounts).
    - **Accounts Held**: Organization Accounts (or subclasses) held by the organization as an account holder (e.g., bank accounts or subscriptions held with another organization).
- Use `getProvidedAccounts()` and `setProvidedAccounts()` for managing accounts the organization provides.
- Use `getHeldAccounts()` and `setHeldAccounts()` for managing accounts the organization holds.
- Can have a parent organization
- Can have child organizations, none of which can be the parent or other ancestor Organization
- Has a type, which there can be an unlimited set of values (not an enum)
- Has a status, which is an enum
- Has members
- Has roles

Organization Account - is an Account and is auditable and enableable
- The Account Provider is an Organization (or a subclass)

Organization Account Holder - an Account Holder for an Account Provider that is an organization or a subclass
- Belongs to an Organization Account

Organization Member
- Belongs to an Organization and not shared with other Organizations
- Has member roles
- Has a user

Organization Role - is named and describable
- Belongs to an Organization and not shared with other Organizations
- Has member roles

Organization Member Role
- Has a member
- Has a role

Organization Type - is named and describable


Service Provider Module:

Service Provider - close but not quite an organization. It's the same in that they manage provided and held accounts. It is named and describable
- Has an AuthenticationType enum, which includes, but is not limited to, NONE, API_KEY BASIC_AUTH, OAUTH1, OAUTH2, JWT, SAML, OPENID_CONNECT, DIGITAL_SIGNATURE, LDAP, SESSION
- Has a ClientRegistrationId
- Can act as both an `AccountProvider` and an `AccountHolder`.
    - **Accounts Provided**: Service Provider Accounts (or subclasses) issued by the Service Provider as an account provider
    - **Accounts Held**: Organization Accounts (or subclasses) held by the Service Provider as an account holder (e.g., bank accounts or subscriptions held with another organization).
- Use `getProvidedAccounts()` and `setProvidedAccounts()` for managing accounts the Service Provider provides.
- Use `getHeldAccounts()` and `setHeldAccounts()` for managing accounts the Service Provider holds.

Service Provider Account - is not an Organization Account. That would add too much complexity. It is an Account and is auditable and enableable.
- The Account Provider is a Service Provider (or a subclass)
- Has a Token Holder

Service Provider Account Holder is an Organization Account Holder
- Belongs to a Service Provider Account

Service Provider Account Token Holder
- Belongs to a Service Provider Account
- Has an accessToken
- Has an AccessTokenExpiry
- Has a RefreshToken
- Has a RefreshTokenExpiry


Security Module:

Authority - represents the permissions or roles granted to a user, defining what actions or resources a user can access.
- Structured to work with JdbcUserDetailsManager.
- Has a username, which links to a User
- Has an authority (role) name
- Has a user
- Has group authorities

Group,
- Structured to work with JdbcUserDetailsManager.
- Is named
- Has group members
- Has group authorities
- Is enableable

Group Authority
- Structured to work with JdbcUserDetailsManager.
- Has an authority (role) name, which links to an Authority
- Has an Authority
- Has a Group

Group Member
- Structured to work with JdbcUserDetailsManager.
- Has a Group
- Has a username, which links to a User
- Has a User

User - It is not a person. A user is simply an authentication method for an account holder to access their account in an organization.
- Structured to work with JdbcUserDetailsManager.
- Has a username
- Is enableable
- Has group members
- Has authorities


Identity Module:

Person - is a real life entity, which is auditable. It is not a user.
- Has a name (first, middle, last)
- Has a birth date
- Can be an account holder, therefore can have accounts.
- Can have contact information sets

Person Contact Information
- Belongs to a person
- Has a type. Ex: home, work, other.
- Has an email address
- Has a street address
- Has a phone number

Layer 1 - Basic Interfaces:
Account - extends NamedLongUniqueObject, has "AccountHolder getHolder()" and "setHolder(AccountHolder)" and "AccountProvider getProvider()" and "setProvider(AccountProvider)"
AccountProvider - extends NamedLongUniqueObject, has "Set<Account> getProvidedAccounts()" and "setProvidedAccounts(Set<Account>)"
AccountHolder - extends NamedLongUniqueObject, has "getHeldAccounts(Set<Account>)" and "setHeldAccounts(Set<Account>)"

Layer 2 - Specific Interfaces:
Organization - extends AccountHolder,AccountProvider
ServiceProvider - extends AccountProvider
Person - extends AccountHolder

Layer 3 - Abstract JPA Entities (MappedSuperclasses):
AbstractNamedLongUniqueEntity - implements NamedLongUniqueObject
AbstractAccountEntity - extends AbstractNamedLongUniqueEntity implements Account
AbstractAccountHolderEntity - extends AbstractNamedLongUniqueEntity implements AccountHolder
AbstractAccountProviderEntity - extends AbstractNamedLongUniqueEntity implements AccountProvider

Layer 4 - Concrete JPA Entities:
AccountEntity - extends AbstractAccountEntity, has "AccountProviderEntity provider" and "AccountHolderEntity holder"
AccountProviderEntity - extends AbstractAccountProviderEntity, has "Set<AccountEntity> providedAccounts"
AccountHolderEntity - extends AbstractAccountHolderEntity, has "Set<AccountEntity> heldAccounts"

Layer 4 - More Abstract JPA Entities (MappedSuperclasses):
AbstractOrganizationEntity - extends AccountProviderEntity AND AccountHolderEntity implements Organization (needs to extend AccountProviderEntity AND AccountHolderEntity because AccountEntity has a reference to AccountProvider AND AccountHolder) (wrong because Java forbids multiple inheritance of classes)
AbstractServiceProviderEntity - extends AccountProviderEntity, AbstractAccountHolderEntity implements ServiceProvider (needs to extend AccountProviderEntity because AccountEntity has a reference to AccountProvider)
AbstractPersonEntity - extends AccountHolderEntity implements Person (needs to extend AccountHolderEntity because AccountEntity has a reference to AccountHolder)

Layer 5 - More Concrete JPA Entities:
OrganizationEntity - extends AbstractOrganizationEntity
ServiceProviderEntity - extends AbstractServiceProviderEntity
PersonEntity - extends AbstractPersonEntity


Given entity class A that has a ManyToOne relationship with abstract MappedSuperclass B which has Entity C and D as concrete entities, how can I get that to work given JPAs restrictions. I want only one table.Example:

@Entity
@Table(name = "examples")
public class A
{
  @ManyToOne 
  @JoinColumn(name="b_id")
  private B something;
}
ChatGPT said:
ChatGPT

To achieve your requirement of using a @ManyToOne relationship to an abstract @MappedSuperclass while persisting all instances of its concrete subclasses (C and D) into a single table, you need to adjust your design to align with JPA's inheritance strategy. JPA does not allow direct relationships to a @MappedSuperclass, as it does not have its own table and exists only to provide reusable mappings.

Here is how you can do this:
Use @Inheritance and @DiscriminatorColumn with SINGLE_TABLE Strategy

Instead of @MappedSuperclass, make B an abstract @Entity with the SINGLE_TABLE inheritance strategy. This allows all instances of C and D to share the same table, with a discriminator column indicating the concrete type.

Here's the revised code:

@Entity
@Table(name = "examples")
public class A {
    @ManyToOne
    @JoinColumn(name = "b_id", nullable = false)
    private B something;

    // Getters and Setters
}

@Entity
@Inheritance(strategy = InheritanceType.SINGLE_TABLE)
@DiscriminatorColumn(name = "type", discriminatorType = DiscriminatorType.STRING)
@Table(name = "b_entities")
public abstract class B {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    // Common fields and methods
}

@Entity
@DiscriminatorValue("C")
public class C extends B {
    // Fields specific to C
}

@Entity
@DiscriminatorValue("D")
public class D extends B {
    // Fields specific to D
}

Explanation of Key Components

    @Inheritance(strategy = InheritanceType.SINGLE_TABLE):
        Specifies that all entities in the hierarchy (B, C, and D) will be stored in a single table (b_entities).

    @DiscriminatorColumn and @DiscriminatorValue:
        The type column is added to the table to indicate which subclass (C or D) an entry belongs to.

    Concrete Relationships:
        A now references B through the @ManyToOne relationship. When persisting an instance of A, you can assign either a C or D instance to the something field.

Benefits of This Approach

    All entities (B, C, and D) share the same table, as per your requirement.
    The discriminator column ensures proper distinction between subclasses.
    JPA supports relationships and polymorphic queries using B as the base type.

Querying

JPA queries automatically handle polymorphism:

A a = entityManager.find(A.class, 1L);
B b = a.getSomething();
if (b instanceof C) {
    System.out.println("This is C");
} else if (b instanceof D) {
    System.out.println("This is D");
}

This approach ensures a clean and JPA-compliant solution for your use case.

You said:
I have to change the problem. A, C and D have their own tables.

ChatGPT said:
ChatGPT

If A, C, and D must each have their own tables, and A has a @ManyToOne relationship to an abstract @MappedSuperclass B, then the correct approach is to use table-per-class inheritance. This way, C and D will have their own tables, but B will still serve as the polymorphic base type.

Hereâ€™s how to adjust the setup:
Updated Code
Entity A:

@Entity
@Table(name = "examples")
public class A {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne
    @JoinColumn(name = "b_id", nullable = false)
    private B something;

    // Getters and Setters
}

Abstract Class B:

@Entity
@Inheritance(strategy = InheritanceType.JOINED) // Use JOINED for normalization or TABLE_PER_CLASS for separate tables
public abstract class B {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    // Common fields and methods
}

Concrete Class C:

@Entity
@Table(name = "c_entities")
public class C extends B {
    // Fields specific to C
}

Concrete Class D:

@Entity
@Table(name = "d_entities")
public class D extends B {
    // Fields specific to D
}

Explanation of the Approach

    @Inheritance(strategy = InheritanceType.JOINED) or TABLE_PER_CLASS:
        Use @Inheritance(strategy = InheritanceType.TABLE_PER_CLASS) to store each subclass (C, D) in its own table without a shared table for B.
        Alternatively, use @Inheritance(strategy = InheritanceType.JOINED) if you want a normalized schema where a shared table (B) contains the common fields, and C and D tables only hold subclass-specific data.

    Relationships in A:
        The @ManyToOne mapping in A allows it to reference any subclass (C or D) of B.
        Polymorphism is supported automatically by JPA.

    Table Design:
        A will have a foreign key column (b_id) referencing the primary key in the tables of C or D.

    Querying:
        You can query B polymorphically. JPA will automatically retrieve the correct subclass instance:

        A a = entityManager.find(A.class, someId);
        B b = a.getSomething();
        if (b instanceof C) {
            System.out.println("This is C");
        } else if (b instanceof D) {
            System.out.println("This is D");
        }

Table Structure for TABLE_PER_CLASS

If using TABLE_PER_CLASS, JPA creates separate tables for C and D without a shared table for B. Each table will have its own set of columns for the fields in B and the subclass-specific fields.

For example:

    Table c_entities: Columns for fields in B + fields in C.
    Table d_entities: Columns for fields in B + fields in D.
    Table examples: Foreign key b_id referencing either c_entities or d_entities.

Considerations

    JOINED Strategy:
        Suitable if you want normalized tables. Queries will use joins to fetch subclass-specific fields.
    TABLE_PER_CLASS Strategy:
        Suitable for complete separation of subclass data but may lead to schema redundancy.
    Discriminator Column:
        Not applicable in TABLE_PER_CLASS strategy but available in SINGLE_TABLE or JOINED.

This design respects the requirement for separate tables while allowing polymorphic behavior and proper foreign key relationships.
