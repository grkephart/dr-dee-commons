Design and Implementation Rules


Section 1: Package Structure and Naming Conventions

Rule 1:
Classes and interfaces should be in separate packages based on the module they belong to. For example, all classes and interfaces related to the organization module should be in the organization package.
The base package should be org.drdeesw.commons.


Section 2: Models and Entity Design

Rule 2:

For the following models, create:
* An interface: Naming convention: {Model}.
* An abstract entity:
  * Use the @MappedSuperclass annotation.
  * Contain all properties, annotated appropriately (@Column, @OneToMany, etc.), and implement the interface.
  * Naming convention: Abstract{Model}Entity.
* A concrete entity:
  * Extend the abstract entity.
  * Use @Entity and @Table annotations.
  * Naming convention: {Model}Entity.
  
Rule 3:

In JPA entity classes, all entity relationships (e.g., @OneToMany, @ManyToOne, @OneToOne, @ManyToMany) must reference concrete, mapped entity classes, not interfaces or generic parameters.
* Avoid: Using generics directly in entity relationship fields.
* Abstract Classes: May define generics in method signatures to support flexibility.
* Concrete Classes: Must resolve generics to specific entity types and ensure proper mapping of relationships.
* These rules apply specifically to entity fields using JPA annotations.
Example:

private Set<OrganizationAccountEntity> accounts;  // Correct

private Set<OrganizationAccount> accounts;       // Incorrect
private Set<A> accounts;                         // Incorrect

Rule 4:

Entity relationships in interfaces should reference interfaces or specific types where generics are not used. 
Avoid defining generics in interfaces.


Section 2: Generics and Type Safety

Rule 5:

Remove generics from interfaces to simplify design.
* Relationships in interfaces should use well-defined interface types (e.g., OrganizationAccount).
* Type handling and conversions should occur in abstract or concrete classes, using explicit casts or helper methods where necessary.

Rule 6:

Minimize the use of raw types and unchecked casts to ensure type safety and maintain clean code.


Section 3: Simplifying Redundancies

Rule 7:
The ServiceProvider class does not need getAccounts() and setAccounts() methods, as these are defined in the Organization class.

Rule 8:

The ServiceProviderAccount class does not need getServiceProvider() and setServiceProvider() methods, 
as these are in the OrganizationAccount class as getOrganization() and setOrganization().
These methods should only exist if they delegate directly to the corresponding methods in OrganizationAccount.

Section 4: Best Practices and Interface Design

Rule 9:
Follow industry standards and best practices. If a conflict arises between these standards and the rules outlined here, highlight it for resolution.

Rule 10:

Create interfaces only when there is a clear need for polymorphism, abstraction, or separation of concerns.
* Avoid introducing unnecessary complexity into interfaces, such as generic parameters, unless there is a compelling reason.

Rule 11: Use Lazy @OneToMany Relationships

Default all @OneToMany relationships to lazy-loading.
Use these relationships primarily to define mappings between entities rather than directly traversing them.
When accessing the "many" side, write explicit queries to retrieve the data as needed.
Explicit queries should be written in the service layer to fetch related entities on the 'many' side as needed

Rule 12: Propagate Generics in Abstract Classes

When an interface defines generic parameters, any abstract class implementing the interface must:
* Declare and Propagate:
  Declare and propagate the same generic parameters to maintain consistency with the interface contract.
* Abstract Class Implementation:
  Use the generic parameters in properties and methods where applicable to ensure alignment with the interface.
* Concrete Class Binding:
  Explicitly bind the generic parameters in concrete classes to avoid type mismatches.
Purpose: This ensures type safety, prevents runtime errors, and maintains clarity in the class hierarchy.

Rule 13: Concrete Types for Persistent Relationships

JPA-mapped fields must always use concrete entity types. 
Avoid using generics (T, A, ?) in JPA entity fields, especially in relationships such as @OneToMany, @ManyToOne, @OneToOne, or @ManyToMany.


Model Definitions:

Note: all entity classes are JPA entity classes.

Common Module:

Auditable - a role interface that contains the following properties:
* CreatedBy is the user who created the record
* CreationDate
* LastUpdateDate
* LastUpdatedBy is the user who last updated the record

Describable - a role interface that contains the following properties:
* description, which is a string

Enableable - a role interface that contains the following properties:
* enabled, which is a boolean

Named - a role interface that contains the following properties:
* name, which is a string


Organization Module:

Account, is an auditable, describable, enableable entity
* Issued by an account provider, such as a bank or other organization
* Has an internal ID which is unique across an account provider. It could be an account number or a username or email or GUID. It is not guaranteed to be unique across all account providers and in fact probably isn't.
* Has a holder, which can be an organization (or subclass) or a person (or a subclass) or a service provider (or a subclass)

Account Holder
* Is a person, organization or integrating system
* Has accounts. Could be multiple accounts with one organization or multiple organizations.

Organization, which is named and describable
* Can have a parent organization
* Can have child organizations, none of which can be the parent organization
* Can be an account holder
* Has a type, which there can be an unlimited set of values (not an enum)
* Has a status, which is an enum
* Has accounts, which can be an Organization Account or a subclass
* Has members
* Has roles

Organization Account, which is auditable and enableable
* The account provider is an organization

Organization Account Holder is an account holder
* Belongs to an organization account

Organization Member
* Belongs to an organization and not shared with other organizations
* Has member roles
* Has a user

Organization Role, which is named and describable
* Belongs to an organization and not shared with other organizations
* Has member roles

Organization Member Role
* Has a member
* Has a role

Organization Type, which is named and describable


Service Provider Module:

Service Provider - not necessarily an organization, but will be considered as one for simplicity. It is named and describable
* Has an AuthenticationType enum, which includes, but is not limited to, NONE, API_KEY BASIC_AUTH, OAUTH1, OAUTH2, JWT, SAML, OPENID_CONNECT, DIGITAL_SIGNATURE, LDAP, SESSION
* Has a ClientRegistrationId
* Has accounts, which can be a Service Provider Account or a subclass

Service Provider Account - is an organization account
* The account provider is an service provider
* Has a token holder

Service Provider Account Holder is an account holder
* Belongs to an account provider account

Service Provider Account Token Holder
* Belongs to a service provider account
* Has an accessToken
* Has an AccessTokenExpiry
* Has a RefreshToken
* Has a RefreshTokenExpiry


Security Module:

Authority, which represents the permissions or roles granted to a user, defining what actions or resources a user can access.. structured to work with JdbcUserDetailsManager.
* Has a username, which links to a User
* Has an authority (role) name
* Has a user
* Has group authorities

Group, structured to work with JdbcUserDetailsManager.
* Is named
* Has group members
* Has group authorities
* Is enableable

Group Authority, structured to work with JdbcUserDetailsManager.
* Has an authority (role) name, which links to an Authority
* Has an Authority
* Has a Group

Group Member, structured to work with JdbcUserDetailsManager.
* Has a Group
* Has a username, which links to a User
* Has a User

User, structured to work with JdbcUserDetailsManager. It is not a person.
A user is simply an authentication method for an account holder to access their account in an organization.
* Has a username
* Is enableable
* Has group members
* Has authorities


Identity Module:

Person, is a real life entity, which is auditable. It is not a user.
* Has a name (first, middle, last)
* Has a birth date
* Can be an account holder, therefore can have accounts.
* Can have contact information sets

Person Contact Information
* Belongs to a person
* Has a type. Ex: home, work, other.
* Has an email address
* Has a street address
* Has a phone number
 