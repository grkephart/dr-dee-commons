Write the following classes and interfaces in Java using JPA annotations. Ensure that the classes and interfaces follow all the rules below.


Rule 1: The classes and interfaces should be in separate packages based on the module they belong to. For example, all classes and interfaces related to the organization module should be in the organization package. 
The base package should be org.drdeesw.commons.

Rule 2: For the following models, there should be 
* an interface. Naming convention is {Model}
* an abstract entity which uses MappedSuperclass annotation and contains all the properties and implements the interface. Properties should have the appropriate Column or OneToMany, etc relationships. Naming convention is Abstract{Model}Entity
* a concrete entity which extends the abstract entity and has the Entity and Table annotations. Naming convention is {Model}Entity

Rule 3: Class-level generics should be used as much as possible to ensure consistency across related entities, allowing for flexibility when adding specific implementations.
As just one example, in the Organization class, the getAccounts() and setAccounts() methods should use the same generic type.

Rule 4: Since I'm using JPA, all entity relationships (e.g., @OneToMany, @ManyToOne, @OneToOne, @ManyToMany) in entity classes must reference mapped entity classes, not interfaces or generic parameters.
Example: it would have to be
  private Set<OrganizationAccountEntity> accounts;
not
  private Set<OrganizationAccount> accounts;
or 
  private Set<A> accounts;
 
Rule 5: Entity relationships in interfaces should use only interfaces or generic parameters.

Removing redundancies:
Rule 6: Service provider does not need getAccounts() and setAccounts() methods since those are in the Organization class.
Rule 7: Service provider account does not need get serviceProvider() and setServiceProvider() methods since those are in the Organization Account class as getOrganization() and setOrganization() methods,
unless those methods simply delegate to the Organization Account class methods.

Rule 8: Use a generic parameter A that extends OrganizationAccount for OrganizationAccountHolder

Rule 9: minimize the use of raw types and unchecked casts


Common Module:

Auditable - a role interface that contains the following properties:
* CreatedBy is the user who created the record
* CreationDate
* LastUpdateDate
* LastUpdatedBy is the user who last updated the record

Describable - a role interface that contains the following properties:
* description, which is a string

Enableable - a role interface that contains the following properties:
* enabled, which is a boolean

Named - a role interface that contains the following properties:
* name, which is a string


Organization Module:

Organization, which is named and describable
* Can have a parent organization
* Can have child organizations
* Can be an account holder
* Has a type, which there can be an unlimited set of values (not an enum)
* Has a status, which is an enum
* Has accounts, which can be an Organization Account or a subclass
* Has members
* Has roles

Organization Account, which is auditable and enableable
* Belongs to an organization
* Has an internal ID. It could be an account number or a username or email or GUID.
* Has a holder, which can be an organization (or subclass) or a person (or a subclass)

Organization Account Holder
* Is a person or an organization
* Has accounts

Organization Member
* Belongs to an organization
* Has member roles
* Has a user

Organization Role, which is named and describable
* Belongs to an organization
* Has member roles

Organization Member Role
* Has a member
* Has a role

Organization Type, which is named and describable


Service Provider Module:

Service Provider - not necessarily an organization, but will be considered as one for simplicity. It is named and describable
* Has an AuthenticationType enum
* Has a ClientRegistrationId
* Has accounts, which can be a Service Provider Account or a subclass

Service Provider Account - is an organization account
* Belongs to a service provider
* Has a token holder

Service Provider Account Token Holder
* Belongs to a service provider account
* Has an accessToken
* Has an AccessTokenExpiry
* Has a RefreshToken
* Has a RefreshTokenExpiry


Security Module:

Authority, which represents the permissions or roles granted to a user, defining what actions or resources a user can access.. structured to work with JdbcUserDetailsManager.
* Has a username, which links to a User
* Has an authority (role) name
* Has a user
* Has group authorities

Group, structured to work with JdbcUserDetailsManager.
* Is named
* Has group members
* Has group authorities
* Is enableable

Group Authority, structured to work with JdbcUserDetailsManager.
* Has an authority (role) name, which links to an Authority
* Has an Authority
* Has a Group

Group Member, structured to work with JdbcUserDetailsManager.
* Has a Group
* Has a username, which links to a User
* Has a User

User, structured to work with JdbcUserDetailsManager.
* Has a username
* Is enableable
* Has group members
* Has authorities


Identity Module:

Person, which is auditable
* Has a name (first, middle, last)
* Has a birth date
* Can be an account holder, therefore can have accounts.
* Can have contact information sets

Person Contact Information
* Belongs to a person
* Has a type. Ex: home, work, other.
* Has an email address
* Has a street address
* Has a phone number

I don't know if a person is a user or not, but I think it would be a good idea to have a separate user entity that links to a person. 
This way, a person can be a user or not, and a user can be a person or not. 
This way, we can have a user that is not a person, like a service account or a system account. 
This way, we can have a person that is not a user, like a contact or a reference or a voter.
 